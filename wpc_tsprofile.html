<!DOCTYPE html>
<html>
<head>
<title></title>
<style type="text/css">
  font: Calibri;
  table, th, td {
    border: 1px solid gray;
    border-collapse: collapse;
  }
  th, td {
    padding: 5px;
    text-align: left;
  }
  tr:nth-child(even) {
    background-color: #eee;
  }
  tr:nth-child(odd) {
   background-color: #fff;
  }
  th {
    background-color: black;
    color: white;
  }
</style>
</head>

<body>
<h2>Estimation of depth by a pressure measurement considering given temperature and salinity profiles</h2>
<hr>
<p>
<b>Brief description</b><br>
Calculation of depth by a given hydrostatic pressure comes from simple equation:
<br>
<br>
<b>P=&rho;gh</b>
<br>
<br>
Where <b>P</b> is pressure, generated by the water column with height <b>h</b> and density <b>&rho;</b>.
The depth <b>h</b> can be estimated as follows:
<br>
<br>
<b>h=(P-P<sub>0</sub>)/&rho;g</b>
<br>
<br>
Where <b>P<sub>0</sub></b> is the atmospheric pressure above the water surface.<br>
But neither <b>&rho;</b>, nor <b>g</b> are constants.
As well as the atmospheric pressure <b>P<sub>0</sub></b> - which in some cases can vary hourly.<br>
Gravity constant <b>g</b> in the simple case is a function of geographic latitude. Since the Earth rotates around an axis
going through north and south poles, gravity force lower on equator due to centrifugal forces and higher on poles.<br>
To estimate the adequate value of gravity acceleration we can use the WGS84 gravity formula<sup><a href="#footnote1">[1]</a></sup><sup><a href="#footnote2">[2]</a></sup>.
In real-world applications water density is a function of water temperature <b>t</b>, salinity <b>s</b> and pressure <b>P</b>.
Its value can be estimated according to the UNESCO equation<sup><a href="#footnote3">[3]</a></sup>.
If we divide the pressure of the whole water column by <b>N<sub>p</sub></b> parts, every lower part will have a higher density (and smaller height)
than higher part due to compression of water. It means that to estimate the proper value of depth we should calculate the following sum:
<br>
<br>
<b>h<sub>&sigma;</sub>=&Delta;P/g&sum;1/(&rho;(P<sub>0</sub>+&Delta;Pi))</b>
<br>
<br>
Estimating the water density for all parts of water column. <br><br>
Almost every deepwater body has a non-homogenous distribution of temperature and salinity, so the most precise way to calculate the depth
is to take into account vertical profiles of temperature and salinity.</p>
<br>
<hr>

<table id="in_values_tbl2">
<caption><b>Input values</b></caption>
 <tr>
   <th>Parameter</th>
   <th>Notation</th>
   <th>Value</th>
   <th>Units</th>
 </tr>
 <tr>
   <td>Number of points</td>
   <td><b>N<sub>tsp</sub></b></td>
   <td><input type="number" step="1" value="10" min="1" max="100" name="Ntsp" id="Ntsp_input" onchange="checkNtsp()"></td>
   <td></td>
 </tr>
 <tr>
   <td>Z coordinate step</td>
   <td><b>Z<sub>s</sub></b></td>
   <td><input type="number" step="1" value="10" min="1" max="1000" name="z_step" id="z_step_input" onchange="checkZStep()"></td>
   <td>m</td>
 </tr>
 <tr>
   <td>Atmosperic pressure</td>
   <td><b>P<sub>0</sub></b></td>
   <td><input type="number" step="0.01" value="1013.25" min="850" max="1095" name="p0" id="p0_input" onchange="checkP0()"></td>
   <td>mBar</td>
 </tr>
 <tr>
   <td>Geographic latitude</td>
   <td><b>&phi;</b></td>
   <td><input type="number" step="0.001" value="48" min="-90" max="90" name="lat" id="lat_input" onchange="checkLat()"></td>
   <td>°</td>
 </tr>
 <tr>
   <td>Number of pressure intervals</td>
   <td><b>N<sub>P</sub></b></td>
   <td><input type="number" step="1" value="1000" min="1" max="100000" name="Np" id="Np_input" onchange="checkNp()"></td>
   <td></td>
 </tr>
 <tr>
   <td>Measured pressure</td>
   <td><b>P</b></td>
   <td><input type="number" step="0.01" value="8000" min="1100" max="1000000" name="P" id="P_input" onchange="checkP()"></td>
   <td>mBar</td>
 </tr>
</table>

<p><input type="button" id="update_table_btn" value="RESET TABLE" onclick="updateTable()"/></p>
<hr>
<p><input type="button" id="set_northern_ocean" value="Set typical northern pacific profile (39°N, 152°W)" onclick="setNPProfile()"/></p>
<p><input type="button" id="set_southern_atlantic_ocean" value="Set typical southern atlantic profile (20°S)" onclick="setSAProfile()"/></p>
<p><input type="button" id="set_arctic_ocean" value="Set typical arctic profile (85°N)" onclick="setAProfile()"/></p>
<hr>
<p><input type="button" id="profiled_calc_btn" value="CALCULATE" onclick="profiled_calc()"/></p>
<div id="cont"></div>
<br>
<br>
<table id="in_values_tbl2">
<caption><b>Estimated depth values</b></caption>
 <tr>
   <th>Notation</th>
   <th>Value</th>
   <th>Units</th>
   <th>Description</th>
 </tr>
 <tr>
   <td><b>h<sub>1</sub></b></td>
   <td><p id="h_rho_fresh_g_const_out"></p></td>
   <td>m</td>
   <td><b>&rho;=1000<sup><a href="#footnote6">[6]</sup></a> kg/m<sup>3</sup>, g=9.80665<sup><a href="#footnote5">[5]</sup></a> m/s<sup>2</sup></b></td>
 </tr>
 <tr>
   <td><b>h<sub>2</sub></b></td>
   <td><p id="h_rho_fresh_out"></p></td>
   <td>m</td>
   <td><b>&rho;=1000<sup><a href="#footnote6">[6]</sup></a> kg/m<sup>3</sup>, g=g(&phi;)</b></td>
 </tr>
 <tr>
   <td><b>h<sub>3</sub></b></td>
   <td><p id="h_rho_sea_g_const_out"></p></td>
   <td>m</td>
   <td><b>&rho;=1023.6<sup><a href="#footnote4">[4]</sup></a> kg/m<sup>3</sup>, g=9.80665<sup><a href="#footnote5">[5]</sup></a> m/s<sup>2</sup></b></td>
 </tr>
 <tr>
   <td><b>h<sub>4</sub></b></td>
   <td><p id="h_rho_sea_out"></p></td>
   <td>m</td>
   <td><b>&rho;=1023.6<sup><a href="#footnote4">[4]</sup></a> kg/m<sup>3</sup>, g=g(&phi;)</b></td>
 </tr>
 <tr>
   <td><b>h<sub>5</sub></b></td>
   <td><p id="h_ts_point_g_const_out"></p></td>
   <td>m</td>
   <td><b>&rho;=&rho;((P-P<sub>0</sub>)/2,t<sub>point</sub>,s<sub>point</sub>), g=9.80665<sup><a href="#footnote5">[5]</sup></a> m/s<sup>2</sup></b></td>
 </tr>
 <tr>
   <td><b>h<sub>6</sub></b></td>
   <td><p id="h_ts_point_out"></p></td>
   <td>m</td>
   <td><b>&rho;=&rho;((P-P<sub>0</sub>)/2,t<sub>point</sub>,s<sub>point</sub>), g=g(&phi;)</b></td>
 </tr>
 <tr>
   <td><b>h<sub>7</sub></b></td>
   <td><p id="h_tsp_const_g_const_out"></p></td>
   <td>m</td>
   <td><b>&rho;=&rho;((P-P<sub>0</sub>)/2,t<sub>mean</sub>,s<sub>mean</sub>), g=9.80665<sup><a href="#footnote4">[5]</sup></a> m/s<sup>2</sup></b></td>
 </tr>
 <tr>
   <td><b>h<sub>8</sub></b></td>
   <td><p id="h_tsp_const_out"></p></td>
   <td>m</td>
   <td><b>&rho;=&rho;((P-P<sub>0</sub>)/2,t<sub>mean</sub>,s<sub>mean</sub>), g=g(&phi;)</b></td>
 </tr>
 <tr>
   <td><b>h<sub>9</sub></b></td>
   <td><p id="h_ts_const_p_int_g_const_out"></p></td>
   <td>m</td>
   <td><b>h=&Delta;P/g&sum;1/(&rho;(P<sub>0</sub>+&Delta;P&middot;i,t<sub>mean</sub>,s<sub>mean</sub>)), i=1..N<sub>p</sub>, g=9.80665<sup><a href="#footnote4">[4]</sup></a> m/s<sup>2</sup></b></td>
 </tr>
 <tr>
   <td><b>h<sub>10</sub></b></td>
   <td><p id="h_ts_const_p_int_out"></p></td>
   <td>m</td>
   <td><b>h=&Delta;P/g&sum;1/(&rho;(P<sub>0</sub>+&Delta;P&middot;i,t<sub>mean</sub>,s<sub>mean</sub>)), i=1..N<sub>p</sub>, g=g(&phi;)</b></td>
 </tr>
 <tr>
   <td><b>h<sub>11</sub></b></td>
   <td><p id="h_tsp_int_g_const_out"></p></td>
   <td>m</td>
   <td><b>h=&Delta;P/g&sum;1/(&rho;(P<sub>0</sub>+&Delta;P&middot;i,t,s)), i=1..N<sub>p</sub>, g=9.80665<sup><a href="#footnote4">[4]</sup></a> m/s<sup>2</sup></b></td>
 </tr>
 <tr>
   <td><b>h<sub>12</sub></b></td>
   <td><p id="h_tsp_int_out"></p></td>
   <td>m</td>
   <td><b>h=&Delta;P/g&sum;1/(&rho;(P<sub>0</sub>+&Delta;P&middot;i,t,s)), i=1..N<sub>p</sub>, g=g(&phi;)</b></td>
 </tr>
</table>
<hr>
<ol>
    <li id="footnote1"><a href="https://en.wikipedia.org/wiki/Theoretical_gravity">Theoretical gravity on wikipedia</a>.
    <li id="footnote2"><a href="http://earth-info.nga.mil/GandG/publications/tr8350.2/wgs84fin.pdf">Department of Defense World Geodetic System 1984 ― Its Definition and Relationships with Local Geodetic Systems,NIMA TR8350.2, 3rd ed., Tbl. 3.4, Eq. 4-1</a>
    <li id="footnote3"><a href="http://www.vliz.be/imisdocs/publications/ocrd/270509.pdf">In situ water density. Millero et al 1980, deep-sea res.,27a,255-264, jpots ninth report 1978, tenth report 1980.</a>
    <li id="footnote4"><a href="https://doi.org/10.1016%2Fj.desal.2016.02.024">Nayar, Kishor G.; Sharqawy, Mostafa H.; Banchik, Leonardo D.; Lienhard V, John H. (July 2016). "Thermophysical properties of seawater: A review and new correlations that include pressure dependence". Desalination. 390: 1–24.</a>
    <li id="footnote5"><a href="http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication330e2008.pdf">Taylor, Barry N.; Thompson, Ambler, eds. (March 2008). The international system of units (SI) (Report). National Institute of Standards and Technology. p. 52. NIST special publication 330, 2008 edition.</a>
    <li id="footnote6"><a href="https://www.simetric.co.uk/si_water.htm">Summary:- Mass, Weight, Density or Specific Gravity of water at various temperatures C and thermal coefficient of expansion of water</a>.
</ol>
<br>

(C) Alek Dikarev, 2020<br>
For bug reports, suggestions and questions, please <a href="https://github.com/AlekUnderwater">reach me</a><br>

<script type="text/javascript">

    var n_pacific_tp = [   12,  7,     3,  2.5,    2,   1.9,   1.8,   1.8,   1.8,   1.8,   1.8,  1.9,    1.9 ];
    var n_pacific_sp = [ 33.8, 34, 34.25, 34.5, 34.6, 34.65, 34.65, 34.66, 34.67, 34.67, 34.67, 34.67, 34.67 ];
    var n_pacific_zstep = 500;
    var n_pacific_phi = 39;

    var s_atlantic_tp = [ 25.6, 20.0, 11.5,  6.5,  4.0,  3.0,  3.0,  3.0,  2.9,  2.8,  2.8,  2.7,  2.5,  2.4,  2.3,  2.2,  2.1,  2.1,  2.1,  2.0,  1.9,  1.8,  1.7,  1.6,  1.5,  1.3,  1.2,  1.1,  1.1 ];
    var s_atlantic_sp = [ 37.2, 36.2, 35.0, 34.4, 34.4, 34.4, 34.7, 34.8, 34.9, 34.9, 34.9, 34.9, 34.9, 34.9, 34.9, 34.9, 34.8, 34.7, 34.7, 34.7, 34.7, 34.7, 34.7, 34.7, 34.7, 34.7, 34.7, 34.7, 34.7 ];
    var s_atlantic_zstep = 200;
    var s_atlantic_phi = -20;

    var arctic_tp = [ -1.8,  -1.1,  1.1,  1.3,  1.1, 0.75,  0.4,  0.2, -0.1 ];
    var arctic_sp = [ 32.8, 34.25, 34.8, 34.9, 34.9, 34.9, 34.9, 34.9, 34.9 ];
    var arctic_zstep = 100;
    var arctic_phi = 85;


    // Calculates gravity acceleration for the given latitude
    // WGS84 gravity formula
    function gravityAcceleration(phi) {
     phi_sq = Math.pow(Math.sin(phi * Math.PI / 180.0), 2);
     return 9.7803253359 * ((1 + 0.00193185265241 * phi_sq) / Math.sqrt(1 - 0.00669437999013 * phi_sq));
    }

    // Calculates depth (distance from the water surface to the point with given pressure)
    // rho - water water density, kg/m^3
    // p0 - atmospheric pressure, mBar
    // g - gravity acceleration, m/s^2
    function depthByPresure(p, p0, rho, g) {
      return (100.0 * (p - p0) / (rho * g));
    }

    function pressureByDepth(h, p0, rho, g) {
      return h * rho * g / 100.0 + p0;
    }

    function depthByPressureSum_TSConst(t, p, s, p0, N_n, g) {
      var dp = (p - p0) / N_n;
      var h_e = 0;

      for (n = 0; n < N_n; n++) {
         h_e = h_e + 1/waterDensity(t, p0 + n * dp, s);
      }

      return 100.0 * h_e * dp / g;
    }

    // Calculates speed of sound in water
    // According to the UNESCO equation: Chen and Millero (1977)
    // t - temperature, °C
    // p - pressure, mBar
    // s - salinity, PSU
    // returns speed of sound in water, in m/s
    function speedOfSound(t, p, s) {

      var t2 = t * t;
      var t3 = t2 * t;
      var t4 = t3 * t;
      p = p / 1000.0;
      var p2 = p * p;
      var p3 = p2 * p;

      var Cw = (1402.388 + 5.03830 * t + -5.81090E-2 * t2 + 3.3432E-4 * t3 + -1.47797E-6 * t4 + 3.1419E-9 * t4 * t) +
                 (0.153563 + 6.8999E-4 * t + -8.1829E-6 * t2 + 1.3632E-7 * t3 + -6.1260E-10 * t4) * p +
                 (3.1260E-5 +  -1.7111E-6 * t +  2.5986E-8 * t2 + -2.5353E-10 * t3 + 1.0415E-12 * t4) * p2 +
                 (-9.7729E-9 + 3.8513E-10 * t + -2.3654E-12 * t2) * p3;

      var A = (1.389 + -1.262E-2 * t + 7.166E-5 * t2 + 2.008E-6 * t3 + -3.21E-8 * t4) +
                (9.4742E-5 + -1.2583E-5 * t + -6.4928E-8 * t2 + 1.0515E-8 * t3 + -2.0142E-10 * t4) * p +
                (-3.9064E-7 + 9.1061E-9 * t + -1.6009E-10 * t2 + 7.994E-12 * t3) * p2 +
                (1.100E-10 + 6.651E-12 * t + -3.391E-13 * t2) * p3;

      var B = -1.922E-2 + -4.42E-5 * t + (7.3637E-5 + 1.7950E-7 * t) * p;

      var D = 1.727E-3 + -7.9836E-6 * p;

      return Cw + A * s + B * Math.sqrt(s * s * s) + D * s * s;
    }

    // linear
    function linterp(x1, y1, x2, y2, x) {
      return y1 + (x - x1)*(y2 - y1)/(x2 - x1);
    }

    // Calculates water density as a function of temperature, pressure and salinity
    // According to:
    // calculates in situ density of water
    // millero et al 1980, deep-sea res.,27a,255-264
    // jpots ninth report 1978,tenth report 1980
    // t - temperature, °C
    // p - pressure, mBar
    // s - salinity, PSU
    // returns water density in kg/m^3
    function waterDensity(t, p, s) {
      p = p / 1000.0;
      var sr = Math.sqrt(Math.abs(s));

      var sig = (4.8314E-4 * s +
                 ((-1.6546E-6 * t + 1.0227E-4) * t - 5.72466E-3) * sr +
                 (((5.3875E-9 * t - 8.2467E-7) * t + 7.6438E-5) * t - 4.0899E-3) * t + 0.824493) * s +
                ((((6.536332E-9 * t - 1.120083E-6) * t + 1.001685E-4) * t - 9.095290E-3) * t + 6.793952E-2) * t - 0.157406;

      var b = ((9.1697E-10 * t + 2.0816E-8) * t - 9.9348E-7) * s + (5.2787E-8 * t - 6.12293E-6) * t + 8.50935E-5;

      var k0 = (((-5.3009E-4 * t + 1.6483E-2) * t + 7.944E-2) * sr +
                ((-6.1670E-5 * t + 1.09987E-2) * t - 0.603459) * t + 54.6746) * s +
               (((-5.155288E-5 * t + 1.360477E-2) * t - 2.327105) * t + 148.4206) * t + 19652.21;

      var a = (1.91075E-4 * sr + (-1.6078E-6 * t - 1.0981E-5) * t + 2.2838E-3) * s +
              ((-5.77905E-7 * t + 1.16092E-4) * t + 1.43713E-3) * t + 3.239908;

      var k = (b * p + a) * p + k0;
      return 1000.0 + (k * sig + 1000.0 * p) / (k - p);
    }

    function numInSetErrState(minV, maxV, elementID, disableElementID) {
      var val = parseFloat(document.getElementById(elementID).value);
      if ((val >= minV) && (val <= maxV)) {
        document.getElementById(elementID).style.border.color = "default";
        document.getElementById(disableElementID).disabled = false;
        return true;
      }
      else {
        document.getElementById(elementID).style.border.color = "salmon";
        document.getElementById(disableElementID).disabled = true;
        return false;
      }
    }

    function checkP0() { numInSetErrState(890.0, 1085.0, "p0_input", "profiled_calc_btn"); }
    function checkLat() { numInSetErrState(-90.0, 90.0, "lat_input", "profiled_calc_btn"); }
    function checkNp() { numInSetErrState(1, 1000, "Np_input", "update_table_btn"); }
    function checkNtsp() { numInSetErrState(2, 100, "Ntsp_input", "update_table_btn"); }
    function checkZStep() { numInSetErrState(1, 1000, "z_step_input", "update_table_btn"); }


    var arrHead = new Array();
    arrHead = ['Point index', 'Z coordinate', 'Approx. Pressure, mBar', 'Temperature, °C', 'Salinity, PSU'];

    function createTable() {
        var empTable = document.createElement('table');
        empTable.setAttribute('id', 'tsProfileTable');
        var tr = empTable.insertRow(-1);
        for (var h = 0; h < arrHead.length; h++) {
            var th = document.createElement('th');
            th.innerHTML = arrHead[h];
            tr.appendChild(th);
        }
        var div = document.getElementById('cont');
        div.appendChild(empTable);
    }

    function updateTable() {
      var Ntsp = parseFloat(document.getElementById('Ntsp_input').value);
      var z_step = parseFloat(document.getElementById('z_step_input').value);
      var tspTable = document.getElementById('tsProfileTable');

      var p0 = parseFloat(document.getElementById('p0_input').value);
      var lat = parseFloat(document.getElementById('lat_input').value);
      var g = gravityAcceleration(lat);


      for (var n = tspTable.rows.length - 1; n > 0; n--) {
        tspTable.deleteRow(n);
      }

      var z = 0;

      for (var x = 0; x < Ntsp; x++) {
        var tr = tspTable.insertRow(x+1);
        for (var c = 0; c < arrHead.length; c++) {
          var td = document.createElement('td');
          td = tr.insertCell(c);

          if (c == 0) {
            td.innerText = x + 1;
          }
          else if (c == 1) {
            td.innerText = (z + z_step * x).toFixed(3);
          }
          else if (c == 2) {
            // approx. pressure
            td.innerText = pressureByDepth(z + z_step * x, p0, 1000, g).toFixed(1);
          }
          else if ((c == 3) || (c == 4)) {
            var ele = document.createElement('input');
            ele.setAttribute('type', 'number');
            ele.setAttribute('step', '0.01');
            ele.setAttribute('value', '0.0');
            td.appendChild(ele);
          }
        }
      }
    }

    function getProfile() {
      var profile = [];
      var tspTable = document.getElementById('tsProfileTable');
      var rowCnt = tspTable.rows.length;

      for (var n = 1; n < rowCnt; n++) {
        var p = parseFloat(tspTable.rows.item(n).cells[2].childNodes[0].textContent);
        var t = parseFloat(tspTable.rows.item(n).cells[3].childNodes[0].value);
        var s = parseFloat(tspTable.rows.item(n).cells[4].childNodes[0].value);
        profile.push([ p, t, s ]);
      }

      return profile;
    }

    function profiled_calc() {
      var tsProfile = getProfile();
      var tsProfileLength = tsProfile.length;
      var pm = parseFloat(document.getElementById('P_input').value);


      if ((pm >= tsProfile[0][0]) && (pm <= tsProfile[tsProfileLength - 1][0])) {
        var p1 = tsProfile[0][0];
        var t1 = tsProfile[0][1];
        var s1 = tsProfile[0][2];
        var p2 = tsProfile[1][0];
        var t2 = tsProfile[1][1];
        var s2 = tsProfile[1][2];

        var Np = parseFloat(document.getElementById('Np_input').value);
        var p0 = parseFloat(document.getElementById('p0_input').value);
        var lat = parseFloat(document.getElementById('lat_input').value);
        var g = gravityAcceleration(lat);
        var g_std = 9.80665;
        var rho_fresh = 1000;
        var rho_sea = 1023.6;

        var t_mean = t1;
        var s_mean = s1;
        var mean_cnt = 1;
        var p_mean = (pm - p0) / 2.0;

        var dp = (pm - p0) / Np;
        var pointIdx = 1;
        var h = 0;
        var p;

        for (var n = 0; n < Np; n++) {
           p = p0 + n * dp;

           if (p > p2) {
             p1 = p2;
             t1 = t2;
             s1 = s2;
             pointIdx++;
             p2 = tsProfile[pointIdx][0];
             t2 = tsProfile[pointIdx][1];
             s2 = tsProfile[pointIdx][2];

             t_mean += t1;
             s_mean += s1;
             mean_cnt++;
           }

           t = linterp(p1, t1, p2, t2, p);
           s = linterp(p1, s1, p2, s2, p);

           rho = waterDensity(t, p, s);
           h += 1/rho;
         }

         t_mean /= mean_cnt;
         s_mean /= mean_cnt;
         var rho_mean = waterDensity(t_mean, p_mean, s_mean);

         var t_point = linterp(p1, t1, p2, t2, pm);
         var s_point = linterp(p1, s1, p2, s2, pm);
         var rho_point = waterDensity(t_point, p_mean, s_point);


         var h_rho_fresh_g_const = depthByPresure(pm, p0, rho_fresh, g_std);
         var h_rho_fresh = depthByPresure(pm, p0, rho_fresh, g);

         var h_rho_sea_g_const = depthByPresure(pm, p0, rho_sea, g_std);
         var h_rho_sea = depthByPresure(pm, p0, rho_sea, g);

         var h_ts_point_g_const = depthByPresure(pm, p0, rho_point, g_std);
         var h_ts_point = depthByPresure(pm, p0, rho_point, g);

         var h_tsp_const_g_const = depthByPresure(pm, p0, rho_mean, g_std);
         var h_tsp_const = depthByPresure(pm, p0, rho_mean, g);

         var h_ts_const_p_int_g_const = depthByPressureSum_TSConst(t_mean, pm, s_mean, p0, Np, g_std);
         var h_ts_const_p_int = depthByPressureSum_TSConst(t_mean, pm, s_mean, p0, Np, g);

         var h_tsp_int_g_const = h * 100.0 * dp / g_std;
         var h_tsp_int = h * 100.0 * dp / g;

         document.getElementById('h_rho_fresh_g_const_out').innerText = h_rho_fresh_g_const.toFixed(3);
         document.getElementById('h_rho_fresh_out').innerText = h_rho_fresh.toFixed(3);
         document.getElementById('h_rho_sea_g_const_out').innerText = h_rho_sea_g_const.toFixed(3);
         document.getElementById('h_rho_sea_out').innerText = h_rho_sea.toFixed(3);
         document.getElementById('h_ts_point_g_const_out').innerText = h_ts_point_g_const.toFixed(3);
         document.getElementById('h_ts_point_out').innerText = h_ts_point.toFixed(3);

         document.getElementById('h_tsp_const_g_const_out').innerText = h_tsp_const_g_const.toFixed(3);
         document.getElementById('h_tsp_const_out').innerText = h_tsp_const.toFixed(3);

         document.getElementById('h_ts_const_p_int_g_const_out').innerText = h_ts_const_p_int_g_const.toFixed(3);
         document.getElementById('h_ts_const_p_int_out').innerText = h_ts_const_p_int.toFixed(3);

         document.getElementById('h_tsp_int_g_const_out').innerText = h_tsp_int_g_const.toFixed(3);
         document.getElementById('h_tsp_int_out').innerText = h_tsp_int.toFixed(3);
      }
      else {
        document.getElementById('h_tsp_int_out').innerText = 'ERROR: specified pressure is beyond the profile';
      }
    }

    function setTSProfile(phi, z_step, t_profile, s_profile) {
      var p_length = t_profile.length;
      document.getElementById('lat_input').value = phi;
      document.getElementById('Ntsp_input').value = p_length;
      document.getElementById('z_step_input').value = z_step;
      updateTable();

      var tspTable = document.getElementById('tsProfileTable');
      var rowCnt = tspTable.rows.length;

      for (var n = 1; n < rowCnt; n++) {

        tspTable.rows.item(n).cells[3].childNodes[0].value = t_profile[n - 1];
        tspTable.rows.item(n).cells[4].childNodes[0].value = s_profile[n - 1];
      }
    }

    function setNPProfile() {
      setTSProfile(n_pacific_phi, n_pacific_zstep, n_pacific_tp, n_pacific_sp);
      profiled_calc();
    }

    function setSAProfile() {
      setTSProfile(s_atlantic_phi, s_atlantic_zstep, s_atlantic_tp, s_atlantic_sp);
      profiled_calc();
    }

    function setAProfile() {
      setTSProfile(arctic_phi, arctic_zstep, arctic_tp, arctic_sp);
      profiled_calc();
    }

    createTable();
    setAProfile();
</script>
</body>
</html>
